# OpenGLを用いたリアルタイム3Dシューティングゲームの作成

<!-- description -->
雪合戦をモチーフにした、OpenGLとWebSocketを用いたリアルタイム3Dゲームを作成した。
<!-- enddescription -->

## ゲームの仕様

### 概要

本ゲームは、OpenGLを用いて、雪合戦を三人称視点でプレイすることのできるゲームである。ゲームを開始するとフィールドが展開され、自分が操作するキャラクターと敵が登場する。プレイヤーは雪玉を投げることができ、これが敵に当たることでダメージを与えることができる。敵が打ってくる雪玉に当たらないように移動しながら、相手に雪玉を投げつけ、相手のHPを先に0にすることが本ゲームの目的である。また、本ゲームでは自機のスキンを4種類のキャラクターから選択してプレイすることが可能である。このキャラクターたちはグループメンバーが個人レポートの際に作成したキャラを登場させるようにした。

本レポートで提出するコードは1対1を想定したものになっているが、設定ファイル(typing.h)にある#define ENEMY_NUMに設定された数字を変更するだけで、ここ以外コードを全く変更せずにマルチ対戦(3人以上の乱戦)に変更することも容易にできるように設計した。以下1対1の場合を想定してレポートを記述するが、操作はマルチ対戦の場合においても同様である。

キャラクター選択とユーザ名の登録をしたらゲームが開始する。ユーザ名はゲーム中には各キャラクターの頭上に表示されるようにした。本ゲームの操作方法は、表2.1に示すように、自分のキャラクターはwasdキーを用いて動かすことができ、マウスのクリックした方向に雪玉を打つことができる。また、プレイヤーは自分の目の前に雪の壁を生成することができ、雪玉をブロックしてくれる。これはスペースキーを押すと作成され、壁は3秒立つと自動的に消滅する。

本ゲームでは雪玉の移動速度がプレイヤーの移動速度よりもかなり速いため、避けるのが困難であり、また玉は0.5秒感覚で打てるように設定した。このためゲーム中は自分も敵も大量の玉を打ちフィールドが玉で覆わる。この狭い隙間を抜けながら相手をエイムする必要があり、かなりスリリングで難易度の高いゲームに仕上がった。

対戦方法としては、コンピューターと対戦するオフラインモードと、友達と対戦できるオンラインモードがある。詳細は以下の章を参照。

### プレイヤーの操作方法

|キー|動作|
|:---:|:---:|
|w|画面奥方向に移動(画面を正面から見て上方向)|
|d|画面右方向に移動(画面を正面から見て右方向)|
|a|画面左向に移動(画面を正面から見て左方向)|
|s|画面手前方向に移動(画面を正面から見て下方向)|
|space|シールドを出す|
|マウスクリック|クリックした方向に玉を投げる|

### 対戦モード

このゲームでは、オンラインとオフライン対戦の2つの対戦モードがある。これは、ゲームを実行直後にターミナル上で選択することができ、1を入力するとオンラインモードになり、0を入力するとオフラインモードが開始される。

オフライン対戦では、コンピュータが操作する敵に勝つことが目的となる。このモードではゲーム内のデータが敵キャラクターを操作するため、ネット回線等に一切接続せずに遊ぶことが可能になっている。コンピュータはランダムウォークをしながら自分に向かってランダムな確率で雪玉を投げてくる。コンピュータのエイムは限りなく正確(玉を打った時点でのプレイヤーの座標をめがけて打つ)ため、つねに避けながら敵に向かって雪玉を投げることが勝つためのコツになる。オフラインモードではマッチング時間がないためすぐに試合を開始することができ、練習にもってこいである。

オンライン対戦では、ネット回線を介して別の人間が操作するキャラクターと戦う。実際の人間と戦うため、かなりの臨場感を味わうことができる。さらに、負けるとものすごく悔しい(筆者談)。オフラインモードでのコンピュータとは異なり、敵プレイヤーは意思を持って攻撃・回避をしてくるため、弾幕を張ったり、相手の回避を先読みして雪玉を打つなどの戦略性が求められる。また、玉をブロックしてくれる雪壁の使い方も非常に重要になってくる。オンライン対戦を開始するには、ホスト(フィールドの新規作成をする人)がサーバに新しいゲームを要求するとゲームIDが与えられる。これを一緒にプレイしたい人に共有し、ゲームに入力することで対戦を開始することができる。ゲームに必要人数(1対1の場合は2人)が集まり次第サーバ内でフィールドのロードが開始され、数秒後にゲームが開始される。

## プログラムの実行方法

以下の通りターミナル上でコマンドを実行することでゲームをプレイすることができる。

流れとしては、main.cなどのプログラムのあるディレクトリにbuildフォルダを作り、カレントディレクトリをそこに移す。そしてcmake ..とコマンドを打つことで、コンパイラに依存せずにプロジェクトファイルを作成することができる。その後、makeコマンドでプロジェクトファイルをビルドすれば、mainという実行ファイルが生成される。これを実行することでゲームが開始する。

```bash
mkdir build
cd build
cmake ..
make
./main
```

## 工夫した点・苦労した点

### 工夫した点

はじめに、本ゲームをグループワークで作成するに当たり、ソースコードの共有はGitHubを用いて行なった。各自がどのような作業をしているかが一目瞭然なこと、また作業内容によってブランチを切り分けることで各自が行なったファイルへの変更が矛盾しても致命的な問題にはならずに開発することができるからである。また、developmentブランチを作成し、これを中心に開発をすすめることで(完成した機能はこのブランチに追加する)バラバラに開発をしていたとしてもどこまで開発が進んでいるかを簡単に共有できるようにした。また、各自で新規機能を追加する際にはdevelopmentブランチより新しいブランチを切り、そこで開発・テストをしたあとで、developmentブランチにプルリクエストを投げて機能を追加するというサイクルを徹底することで着実に開発を進めていった。一般的にファイル共有をラインやGoogle Drive等を用いる場合では、みんなが作ったファイルを集め、組み合わせるといった作業(つまり中央集権的な開発)をしなければならないが、このサイクルを徹底するだけで自発的に各自で作成したものが組み合わさっていくため、まとめ役が必要なく、みなが均等に作業をし、また新機能の追加に注力することが可能になった。またプルリクエストの承認という手順を挟むことで二重のチェックをし、バグやコンフリが発生しないように最大限の努力をした。結果として急にプログラムが動かなくなったり、謎の変更がなされていたりといった問題は一切発生せず、快適に開発をすることができた。

また、自主的に授業時間外でもZoomで週一回程度集まることで、進捗状況の共有をしながら困っていることの相談もしつつ、皆でプログラムを作成することができた。

次にゲームで工夫した点を記述する。

本課題にとりかかるにあたり、最もこだわった点は、バトル形式にしたということである。テトリスやインベーダーゲームといった、乱数によるばらつきを除いて毎回完全に状況が再現されるゲーム(静的ゲームと呼ぶとする)では、生成される状態数に限りがあり、結果がある程度わかってしまう。特に開発者は乱数のシード値を固定してデバッグするため、完全に同じ状況を何度もデバッグすることになり、モチベーションが起きずすぐに飽きてしまうと考えた。一方でバトル形式などの動的な変化が発生するゲームでは開発者ですら何が起こるかを予想することができないため、開発者自身が楽しめる形式であることから、バトル形式のゲームを作ることにした。さらに、静的ゲーム、例えばスーパーマリオブラザーズなどでは、ユーザを飽きさせないためには新しいステージを追加するといったことをする必要がある。ステージを何種類も作成するには多くの時間がかかり、かと言ってステージの種類が少ないとあまり楽しむことができない。本課題では3週間という短い期間で開発をしなければならないため、フィールドを用意するだけで無限の可能性が作り出せるバトル形式のゲームが適していると考えた。

加えて、本ゲームにはオンライン対戦機能を搭載した。現在新型感染症のため友達と会うことすら簡単にはできなくなってしまったため、離れていても一緒に遊べるゲームを作成したいと考えた。オンライン対戦を実装するに当たり、コネクション方式にwebsocketsを採用し、リアルタイム通信を可能にした。websocketはTCPプロトコルの技術を用いて実装されるクライアントとサーバの対話的なセッションを可能にする比較的新しい技術である。従来のTCP通信では、サーバはクライアントからのリクエストを受け取ることでレスポンスを送る処理を発火させることしかできないが、websocketではサーバ側からも任意のタイミングで能動的に通信が可能になった。さらに接続中はコネクションを常に確保し続けるため、通信のたびにセッションを作成するTCP通信と比べて圧倒的に速い送受信が可能である。多くのRPGやFPSなどのラグの少なさが要求されるゲームではこの技術が用いられており、私も今回良い機会だと思い、実装してみた。さらに、websocketをただ用いるだけでなく、ユーザがラグを感じさせないように工夫をした。一般的なシューティングゲームでは、ユーザが玉を打つとそれを他ユーザに共有し、玉の座標を(例えば場外に消えるまで)送信し続ける。しかしこれではラグの分だけ古い情報が伝わる。(今回のゲームの場合ラグの実測値はおおよそ0.09秒であった。)そこで、今回は以下の方法を用いた。ユーザが玉を打った瞬間に現実世界での時刻を取得し、玉の情報、玉の速度、その時刻をサーバに送信する。サーバはその情報を他のプレイヤーに伝え、情報を受け取ったプレイヤーは、受け取った時点での現実世界の時刻を取得し、送られて来た時刻との差を計算することで、この玉が何秒(μs)前に打たれたものであったかを計算する。その時間の間に進んだ距離を玉の速度から計算して画面に表示させることで、玉の現在の表示位置を完全に同期させることができる。これはシューティングゲームの玉はどこから発射されたかよりもどこに着弾するかの情報のほうが、人間にとって大事だという性質を利用した。また、以降の玉の座標は、速度がわかっているため、各プレイヤーがローカルで計算し、玉を打ったプレイヤーが玉の位置の更新を逐一送信する必要がなくなるため、通信量を減らすことにもつながった。通信量が減ったことで余った帯域を使用してユーザの現在位置を全力で送信し続けることで、敵位置の描画も若干速くすることができる。(プレイヤーの位置は計算で予測するなどができないため、最新情報を更新し続けるしかない。)なお、実際には各コンピュータが保持する現在時刻の情報も若干ずれているため、ゲーム開始時にそのずれを確認しておき、それも考慮して計算をしている。

加えて、今回のゲームでは見た目も非常にこだわって作った。視点を真上からではなく、ある程度斜めにすることで、キャラクターがよく見えるようにした。また、雪を表現するためにフィールドを真っ白に設定すると、雪玉や雪の壁なども同じく白いため、完全に見えなくなってしまう。そこで、フィールドの地面の色は少し青がかった白とし、他のオブジェクトの色と差をつけ、さらに壁や雪玉は影をつけ、見やすくした。さらにフィールドの境界線はボーダーの模様を敷いた。フィールドの外は空を表現するために青くした。この青色は本物の空を撮影し、写真の色を解析して設定した。また、観客に見立てた雪だるまをフィールドの周りに設置した。(かわいい。)

さらに、キャラクターの頭上には、ユーザが登録したユーザ名と残りHP表示させ、画面上部には操作方法を説明した図を追加した。そしてキャラクターは進む方向に合わせて常に回転させて描画した。これは上下左右だけでなく、→と↑を同時に押した場合などのように、斜め移動にも対応しており、そのときは斜め45度を向くよう設定した。

最後に、実装において工夫した点を記述する。

玉と物体の当たり判定は、玉を円、物体を長方形として扱い、2次元平面での計算を行なった。平面で行なうことで次元を一つ削減することができ、計算量を抑えることができるため、計算機への負荷を減らすことが可能になった。さらにすべての物体(プレイヤーと壁)を長方形にすることで、長方形の頂点を渡すと玉との当たり判定をしてくれるという同じ関数を使いまわして判定することができる。よって開発時間の短縮につながった。また、オブジェクトの当たり判定は長方形にするのが最も直感的でもある。(描画されているものに最も似ているため、実際に当たっているように錯覚させられる。)

また、今回のゲームはオンラインモードとオフラインモードの2種類を提供している。これを愚直に実装すると、オンラインとオフラインの処理は別々に記述することになり、例えば当たり判定など、どちらでも使用する処理は2回記述する事になってしまう。これは開発時間を増やすだけでなく、デバッグも大変になり、非常に非効率的になってしまう。そこで、これらのゲームモードの差はサーバとの接続方法のみとなるような設計をし、その差をサーバ通信を行なう関数の中に隠蔽することで、この問題を解決した。つまり、オフラインモードにおいても、あたかもローカルにある架空のサーバに接続しているかのような設計を採用することで、上位層の処理(玉を打ったりプレイヤーが移動したりする「ユーザに近い」関数)から見て、オンラインとオフライン関係なく同じ関数を呼ぶだけで同様のレスポンスが得られるような実装をすることに成功した。これは、ゲームIDの0番を予約語とし、オフライン対戦専用のゲームIDとすることで、オンラインモードかオフラインかを見分けている。つまり、例えば玉を打つという処理をする時には、その関数からはオンラインかオフラインかを全く考えず、サーバに新しい玉を登録する関数(ws_sendNewBullet)を呼び出すだけでよく、ws_sendNewBullet内でゲームIDが0かを確認し、どのサーバに問い合わせるかを分岐させている。これによりオンラインとオフラインでほとんど処理を分けることなく実装ができるようになるため、開発時間を大幅に短縮することができた。ただ、オフラインの際に本当にローカルにサーバを立てるのはかなりコストが高いのでしておらず、Unixが提供する共有メモリ機能がかなりwebsocketの機能と似ていることから着想を得て開発を行なった。(実際のこれらの中身の実装は全く異なるものだが、プロセス間で通信を行なう共有メモリの考えを参考にしてクライアントとサーバ間で行なうためにwebsocketが開発された一面もある。)なお、今回の実装では共有メモリを使うよりマルチスレッドで同一メモリ参照できる方が高速なので、敵の処理を別のスレッドで実行しているだけであるが、あたかもサーバと通信をしているように見せかけている。

さらに、サーバとの通信はかなりコストが高いため普通であればオンライン時のほうがレンダリング速度が落ちるが、今回非同期処理を用いてることで、影響がなるべくでないようにした。新しく玉をサーバに登録する処理や、プレイヤー座標の更新などの処理を別のスレッドに担当させることで、メインスレッドでは通信の終了を待たずして次の処理を実行でき、オンライン対戦時にもfps(フレームレート)をほとんど下げずに済む工夫をした。さらに自機座標が変更されていない場合はそもそもサーバにデータを送信しないといった工夫をすることでできるだけ負荷を減らすよう努めた。

また、本ゲームを開発するに当たって、構造体への参照は必ずポインタ参照にすることを徹底した。構造体を実体参照する場合、関数の呼び出しの直前に構造体の中身をディープコピーするが、これが非常に時間のかかる処理である。一方でポインタ参照は32bitのコピーで済むため非常に高速に実行が可能である。その代わりポインタ参照にすることで、セグメンテーションフォルトや実体のないポインタへの参照などが起きてしまう確率が格段に増えてしまい、これらのエラーをデバッグするのに最も時間を要した。デバッガを用いてメモリの使用をチェックし、メモリリークなどが発生しないようにいつも以上に気をつけて開発を行なった。

また、玉の間を縫って移動するため、ユーザが押したキーに対するかなり正確で高速なレスポンスが要求される。授業スライドでも注意書きがあったようにglutKeyboardFuncとglutTimerFuncを組み合わせることでユーザのキー入力を取得した。

### 苦労した点

C言語は構造体主体言語である。オブジェクト指向でないプログラミング言語でゲームを開発するのは非常に困難である。構造体主体言語ではその言語思想から、構造体と手続きを最初に設計するといったトップダウン的な設計をする必要があり、仕様変更を頻繁にするゲーム開発との相性は最悪である。特に複数人で開発する際には他人の書いた手続きを呼び出す必要があるため、さらに開発が難航する。本ゲームの開発では、なるべく齟齬をなくすため、Google Docsを用いてリアルタイムに共有できる仕様書を作成し、各手続きの引数や戻り値の型、またそれらの意味と要求を事細かに記載し、さらにソースコード内でも大量のコメントを記述した。手続きを洗い出し、各手続きに対応する関数名を仕様書に書くことで、逆に関数の中身を隠蔽し、関数を呼び出す側は中の実装を気にする必要がなく、関数を実装する側は仕様書に定められた要件を満たすものを作成することに注力できるため、各自の仕事を明確に分離することができた。本ゲームの開発で実際に作成した仕様書はリンクであり、念のため当レポートの末尾にも添付する。

また、今回班員の中で授業受講以前からOpenGLを使っていた人は1人もいなかった。知識があまりなく、初歩的なこともどのように記述すればよいかわからず、授業スライドを見返しながらみんなで相談して書いたため、その面で苦労した。また、OpenGLはリアルタイム描画よりも3Dレンダリングをすることに向いており、OpenGLを用いて3Dゲームを作成している人が少なく、文献があまり存在しないことも難易度が上がった原因の1つだと考える。特にフレームレートを維持するための処理の高速化に関する記事はほとんど見つけることができず、複雑なオブジェクトの描画、例えば地面に雪山のように凹凸をつけたかった(texture20フォルダ内にソースコードがあるが、ゲーム処理中に1度も呼ばれていない)を断念せざるを得なかった。

本ゲームではマウスクリックをすると、ポインタの座標に向かって玉が打てるという仕様を採用した。しかしマウスポインタの座標はウィンドウとの相対位置である二次元データであるのに対し、玉は空間内の三次元データであるため、変換が難しかった。また、正統な方法は3次元空間をカメラの座標を元に二次元データに変換する行列の逆行列を求め、そこからマウスポインタが指す線分を計算し、それと地面(今回の実装ではy=0平面)との交点を求めることで計算可能である。しかしこの計算がそこそこの計算時間を必要とし、またゲームの仕様上ユーザはかなりの回数クリックするため、今回の実装では採用せず、代わりにマウスポインタのxy座標から単純な2変数1次式を用いて空間座標を計算した。この手法でマウスポインタの方向へ玉が飛んでるように見える式を作成するのにかなり苦労した。

また、本ゲームでは前節で記述したように、当たり判定はすべて長方形と円の当たり判定で行なった。こうすることで当たり判定の関数を1度記述するだけで済み開発時間を削減することができるが、そもそも長方形と円の当たり判定が非常に難解であった。本ゲームでは上下左右だけでなく、斜め移動なども許容しており、さらに連続値(double型)で座標表現をしているため、任意の座標において、任意の角度回転した直方体との当たり判定を記述する必要があった。また、今回はカメラから見て横軸をx軸、縦軸をy軸、手前・奥行きをz軸で表現した。つまり地面はxz軸からなるものである。さらに長方形の回転角度をx軸正方向を0度としてy軸反時計回りの回転角(rad)と定義したため、いつも使用している座標系(xy軸の平面座標)とかなり違い、余計に混乱してしまった。

また、OpenGLにはフレームレート(fps)を固定する関数が存在しない。これは特にオンライン対戦では致命的で、愚直に実装するとマシンパワーが優れている方が移動速度が速くなってしまう。この問題を解決する方法を模索するのにかなりの時間を要した。最終的には、キャラクターの移動量などを、現実世界の時刻に依存させて更新することで、環境差分をなくすことができた。なおこれは、フレームレートは一切変えておらず、マシンパワーが出せる最大速度を保つため、強いマシンであるほどキャラクターの移動等がなめらかに見え、マシンスペックが弱い場合には紙芝居のように描画されてしまう。しかしゲーム内の変数の更新頻度をフレームレートではなく現実世界の時刻に依存させているため、有利不利をなくすことに成功した。また、この方法を用いることで、前節で記述したように、玉の移動の計算をそれぞれのプレイヤーがローカルで別々に行なっても、全員同じ場所に玉が表示されるようにできた。

また、websocketの実装も大変苦労した。そもそもwebsocketは新しい技術で、非対応のプラットフォームも多く存在する。高級言語(pythonやgoなど)ではオープンソースのライブラリが提供されており、比較的簡単に実行することが可能だが、C言語にwebsocket関連のAPIを提供するライブラリは存在せず、個人のgitレポジトリ(参考文献7)を参考にして自力で実装する必要があった。さらに参考にしたソースコードはwebsocketの制御フレーム処理がバグっており、はじめは全く通信が成功しなかった。バグが発生してもエラーが出力されなかったため、うまく行かない原因を探すところから始まり、さらに制御フレームの処理はwebsocketの仕様の知識が必要なため、公式ドキュメントを参考にしながらソースコード変える必要がありかなり苦労した。加えて、非同期的な処理をしておらず、そのまま使用すると描画のフレームレートが落ち込んでしまったため、非同期処理を自分で実装する必要があった。

さらに、グループワークだったことで、環境差分をなくすのに非常に苦労した。このグループにはWindowsでWSLを使用する人とMacOSを使用する人がおり、例えば#include <GL/glut.h>を記述するだけでMacの環境ではコンパイルができなくなってしまう。自分の環境でテストし、ちゃんと動くことを確認してプルリクエストを投げたのにも関わらず、別の環境では動作しないという現象が度々発生した。マクロや#ifdef __APPLE__等を使用することで、どの環境においてもコンパイルできることを確認しながら開発する必要があった。特にwebsocketの実装はMacで対応していない機能を多く使っていたため、Macでも同様に動くように書き換える必要があった。websocketを主に書いていた糸井がWindowsユーザーだったためMacで実行ができることを逐一別の人に確認してもらわなければならず、開発に余計に時間がかかってしまった。

また、オンライン時の敵は敵側のパソコンで当たり判定等を計算してもらえばよいが、オフライン時の敵は実際にはローカルで計算をする必要があった。先述したように、オフライン時にも擬似的にサーバを介して情報のやり取りをするような設計にしたため、サーバの向こう側にいる敵の当たり判定をしてあげないといけないといった複雑な処理をすることになってしまった。敵の処理を違うスレッドを立てそこで計算させることで処理を分断し、一方で別スレッドからもグローバル変数は共有できるという性質を活かし、敵の位置情報をグローバル変数に格納してメインスレッドからも参照可能にした。しかしこれでは複数スレッドから同一メモリへの参照が続き、スレッドセーフでなくなってしまうため、pthreadライブラリが提供するmutexをうまく用いて排他制御を行ない、意図しないデータの書き込み等を防いだ。

このように多くの機能を実装したため、ファイルが大量になり、すべてのファイルの中身を全員が把握することが難しくなった。さらに各ファイルが別ファイルを参照するため、各プログラムの依存関係が非常に複雑になっていった。そこで、ファイルのコンパイルはcmakeを用いて行ない、コンパイル方法をCMakeListsに書き込むことでソースコードを見ずとも必要なライブラリや依存関係がひと目で分かるような工夫をした。cmakeを使ったコンパイルをしたことのある班員が少なく、はじめは困惑していたが、徐々に慣れてくると依存関係の管理が非常に楽になった。また、各機能を追加する際にはテストをすることを義務化し、またテストに使用したファイルをtestフォルダに入れておくことで、他の人がその機能を使いたいときにはテストでの使い方を見ることでどのような使いかたをすればよいかがわかるため、言葉で共有するよりも楽に各関数の使い方を共有することができた。

ゲームIDの新規作成や管理、データの送受信等を司るサーバの実装に関しては課題と直接関係はないので省略する。

## 参照したWebサイト，著作物

- [github初心者はForkしない方のPull Requestから入門しよう](https://blog.qnyp.com/2013/05/28/pull-request-for-github-beginners/)
- [円と長方形の当たり判定](http://ftvoid.com/blog/post/300)
- [情報メディア実験](http://slis.tsukuba.ac.jp/~fujisawa.makoto.fu/lecture/iml/text/screen_character.html)
- [第１回 画像の読み込み](http://marina.sys.wakayama-u.ac.jp/~tokoi/)
- [GLUTによる「手抜き」OpenGL入門](https://tokoik.github.io/opengl/libglut.html)
- [Writing WebSocket servers](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers)
- [libwsclient](https://github.com/payden/libwsclient)

## リンク

- ソースコードを置いたGitHubの[ディレクトリ](https://github.com/pysan3/capp_group): pysan, capp_group,
- サーバ側の処理を記述したGitHubの[ディレクトリ](https://github.com/pysan3/freeroomfinder): pysan, freeroomfinder,
  - (個人情報が含まれるためプライベートレポジトリになっている)
